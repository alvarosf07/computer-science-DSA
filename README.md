## Data Structures and Algorithms - Optimized Problem Collection (DSA-OPC)

Welcome to the Data Structures and Algorithms Optimized Problem Collection!

This repository houses a carefully curated selection of the most relevant DSA problems sourced from reputable platforms like LeetCode, Elements of Programming Interviews, and other authoritative texts.

<br/>




### Motivation

Many people do more than 300 coding questions to prepare for coding interviews. It is **NOT NECESSARY** to do this. After reviewing many different sources (LeetCode, HackerRank, GeeksforGeeks, Elements of Programming Interviews... see all below) I have collected a curated selection of the ~100 most relevant problems, organized by categories, classes and difficulty levels. 

This collection aims to simplify your learning curve by providing a structured and focused selection of 5-10 problems for each DSA category, that will help you understand the "general type" of questions so you can reduce your workload by 80%, focusing only on the 20% of problems that matters the most.

#### Author's Note: 
> There are plenty of "Best lists" for DSA that can be found online (see resources below). The purpose of this repository is not to be the "ultimate" collection of DSA problems. I decided to create this collection to better understand the field of DSA while I prepared for coding interviews, and help others do the same for free. It includes problems that I've come across and from my *personal* point of view, I've found most relevant. At the same time, it's organized following a structure I personally find intuitive and practical for understanding of Data Structures and Algorithms, but it doesn't intend to be a 100% unique representation of reality.

<br/>





### Features

- **Curated Selection:** I've handpicked the most relevant problems to ensure you focus your time and effort on mastering essential concepts.
- **Optimized Learning:** The collection is designed with the 80/20 principle in mind: focusing on achieving 80% of the learning with just 20% of the effort, saving you valuable time and energy.
- **Structured Learning Path:** The collection follows a progressive learning path, guiding you through increasingly challenging problems to build your skills step by step.
- **Versatile Content:** Whether you're a beginner starting your DSA journey or an experienced programmer looking to sharpen your skills, I believe this collection can be helpful for you in some way.

<br/>





### Organization
DSA problems are classified into 5 fields:
   1. Abstract Data Types
   2. Data Structures
   3. Algorithms
   4. Systems Design (still work in progress)
   5. Coding Interview Problems

<br/>

Each field is divided into subsequent sub-fields, as depicted in the mind map above. Within each sub-field, problems are (mostly) classified in 4 main categories:
<ol start="0"> 
  <li> <b>Foundational Problems</b> </li>
  Aim to provide a general introduction to the sub-field, and present the basic operations and functionalities in the form of short and to-the-point exercises. Foundational problems are not usually asked in practical coding interviews, but can be asked sometimes as part of "theoretical understanding" of a specific data-type or data-structure. In this repository, foundational problems are only introduced for Python at the moment, but some other languages (JAVA, C++) may be added in the future.
</ol>
<br/>

<ol start="1"> 
  <li> <b>Easy Problems</b> </li>
  Easy problems include practical questions that involve using the properties/advantages of the sub-field of study. They're ideal to tackle right after the foundational problems to strengthen the understanding of the DSA sub-field. Easy problems are commonly asked as introductory questions in early/middle round coding interviews, and should take between 5-20 min to complete.
</ol> 
<br/>


<ol start="2"> 
  <li> <b>Medium Problems</b> </li>
  Medium problems are challenging problems that already require a decent level of skill using a specific DSA sub-field. They usually involve using a specific type of algorithm that works well for a particular set of problems. Medium problems are typically the ones that you can expect as "main question" in most coding interviews. They typically take between 15-40 min to solve for the first time.
</ol> 
<br/>

<ol start="3"> 
  <li> <b>Hard Problems</b> </li>
  Hard problems are very challenging (and tricky) problems that require not only a good mastery of the specific DSA sub-field, but also good knowledge and skills with algorithms and most importantly: good coding intuition. Most of the hard problems require realizing a certain trick or alternative formulation that makes the question easier to solve. Hard problems are asked in coding interviews mainly oriented to heavy software-developer roles, or certain positions in finance that require strong problem-solving skills. Depending on the coding expertise, hard problems can take from 15 minutes to several hours to solve; although is common to give up before finding a solution. For time optimization purposes, it's recommended to look at the solution of hard problems if no meaningful progress towards the solution has been made after 30-40 minutes.
</ol> 
<br/>
  


<br/>






### Getting Started

1. **Explore Categories:** Browse through our organized categories to find problems that align with your interests and skill level.
2. **Challenge Yourself:** Dive into the problems, solve them, and test your understanding of key DSA concepts.
3. **Track Your Progress:** Keep track of your progress as you tackle each problem, and celebrate your achievements along the way.

<br/>





### Contributing

We welcome contributions from the community to enhance and expand our problem collection. If you have suggestions for additional problems, improvements to existing ones, or any other feedback, please feel free to contribute!

<br/r>




### Let's Get Started!

Ready to embark on your journey to DSA mastery? Explore the collection, challenge yourself with the problems, and let's take your programming skills to new heights together!

Happy coding! ðŸš€

